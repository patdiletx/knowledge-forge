import * as vscode from 'vscode';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { AIServiceFactory } from '../services/AIServiceFactory';
import { ProjectStateService } from '../services/ProjectStateService';
import { ConfigService } from '../services/ConfigService';
import { IntelligentCacheService } from '../services/IntelligentCacheService';
import { MicroLearningService, MicroLesson } from '../services/MicroLearningService';
import { EducationalHintsService, Hint } from '../services/EducationalHintsService';

/**
 * Estado del aprendizaje de una tarea
 */
interface TaskLearningState {
    currentStep: number;
    completedSteps: number[];
    chatHistory: { role: 'user' | 'ai'; message: string }[];
    cachedSteps: { [stepNumber: number]: any }; // Cache de pasos ya generados
    sessionId?: string; // ID for micro-learning session
    lessons?: MicroLesson[]; // Micro-lessons for this task
}

/**
 * Panel interactivo de aprendizaje para cada tarea
 * Sistema dinámico paso a paso con IA como mentor
 */
export class TaskLearningPanel {
    public static currentPanel: TaskLearningPanel | undefined;
    private readonly _panel: vscode.WebviewPanel;
    private readonly _extensionUri: vscode.Uri;
    private readonly _context: vscode.ExtensionContext;
    private _disposables: vscode.Disposable[] = [];
    private readonly _stepNames = [
        '🎯 Entender el Objetivo',
        '📚 Conceptos Clave',
        '💡 Ejemplo Guiado',
        '✍️ Tu Turno - Práctica',
        '✅ Validación'
    ];
    private _learningState: TaskLearningState;

    public static async createOrShow(
        extensionUri: vscode.Uri,
        context: vscode.ExtensionContext,
        phaseIndex?: number,
        taskIndex?: number,
        roadmapId?: string
    ) {
        const column = vscode.ViewColumn.One;

        // Si ya existe un panel, mostrarlo
        if (TaskLearningPanel.currentPanel) {
            TaskLearningPanel.currentPanel._panel.reveal(column);
            await TaskLearningPanel.currentPanel._refresh();
            return;
        }

        // Crear nuevo panel
        const panel = vscode.window.createWebviewPanel(
            'knowledgeForgeLearning',
            '📚 Modo Aprendizaje - KnowledgeForge',
            column,
            {
                enableScripts: true,
                localResourceRoots: [extensionUri],
                retainContextWhenHidden: true
            }
        );

        TaskLearningPanel.currentPanel = new TaskLearningPanel(panel, extensionUri, context, phaseIndex, taskIndex, roadmapId);
    }

    public postCodeToExplain(code: string) {
        this._panel.webview.postMessage({ type: 'codeToExplain', code: code });
    }

    private constructor(
        panel: vscode.WebviewPanel,
        extensionUri: vscode.Uri,
        context: vscode.ExtensionContext,
        private readonly phaseIndex?: number,
        private readonly taskIndex?: number,
        private readonly roadmapId?: string
    ) {
        this._panel = panel;
        this._extensionUri = extensionUri;
        this._context = context;

        // Estado inicial
        this._learningState = {
            currentStep: 0,
            completedSteps: [],
            chatHistory: [],
            cachedSteps: {},
            sessionId: undefined,
            lessons: undefined
        };

        // Configurar contenido inicial
        this._update();

        // Escuchar cuando el panel es cerrado
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // Manejar mensajes desde el webview
        this._panel.webview.onDidReceiveMessage(
            async (message) => {
                try {
                    console.log('[TaskLearningPanel] onDidReceiveMessage:', message.type, message);
                    switch (message.type) {
                        case 'loadStep':
                            await this._handleLoadStep(message.stepNumber);
                            break;
                        case 'completeStep':
                            await this._handleCompleteStep(message.stepNumber);
                            break;
                        case 'completeTask':
                            await this._handleCompleteTask();
                            break;
                        case 'askAI':
                            await this._handleAskAI(message.question);
                            break;
                        case 'continueStep':
                            await this._handleContinueStep(message.stepNumber);
                            break;
                        case 'openInSandbox':
                            await this._handleOpenInSandbox(message.code || '');
                            break;
                        case 'closePanel':
                            this.dispose();
                            await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
                            break;
                        case 'requestHint':
                            await this._handleRequestHint(message);
                            break;
                        case 'requestHelp':
                            await this._handleRequestHelp(message.stepNumber);
                            break;
                        case 'nextLevelHint':
                            await this._handleNextLevelHint(message);
                            break;
                        case 'navigateToNextTask':
                            try {
                                // Close current panel first
                                this.dispose();

                                // Advance the project pointer to next task
                                await vscode.commands.executeCommand('knowledgeforge.nextTask');

                                // Re-open the learning mode for the new current task
                                await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
                            } catch (err) {
                                console.error('Error navigating to next task:', err);
                            }
                            break;
                        case 'webviewError':
                            // Forward webview rendering/parsing errors to Extension Host logs for debugging
                            try {
                                console.error('[TaskLearningPanel] Webview reported error on step', message.stepNumber + ':', message.error);
                                vscode.window.showErrorMessage('KnowledgeForge webview error: ' + (message.error || 'unknown error'));
                            } catch (e) {
                                console.error('Failed to handle webviewError message:', e);
                            }
                            break;
                        default:
                            console.warn('[TaskLearningPanel] Unknown message type:', message.type);
                    }
                } catch (err) {
                    console.error('[TaskLearningPanel] Error handling message:', message, err);
                }
            },
            null,
            this._disposables
        );

    }

    private async _refresh() {
        // Initialize micro-learning session if not already done
        if (!this._learningState.sessionId && this.phaseIndex !== undefined && this.taskIndex !== undefined) {
            const taskId = `${this.roadmapId || 'default'}-${this.phaseIndex}-${this.taskIndex}`;
            const session = MicroLearningService.getSession(this._context, taskId) || 
                           MicroLearningService.startSession(this._context, taskId, this._stepNames);
            
            this._learningState.sessionId = session.taskId;
            this._learningState.lessons = session.lessons;
        }
        
        this._update();
    }

    private async _handleOpenInSandbox(code: string) {
        try {
            // Create a temp file to avoid using the untitled: scheme which causes FS provider errors
            const tmpDir = path.join(os.tmpdir(), 'knowledgeforge_sandbox');
            if (!fs.existsSync(tmpDir)) {
                fs.mkdirSync(tmpDir, { recursive: true });
            }

            const filePath = path.join(tmpDir, `sandbox_${Date.now()}.ts`);
            fs.writeFileSync(filePath, code || '', 'utf8');

            const document = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            await vscode.window.showTextDocument(document, vscode.ViewColumn.Beside);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({ type: 'error', message: `Error abriendo sandbox: ${errorMessage}` });
        }
    }

    private async _handleCompleteTask() {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                this._panel.webview.postMessage({ type: 'error', message: 'No hay proyecto activo' });
                return;
            }

            // Complete current task and get whether there's a next
            const result = await ProjectStateService.completeCurrentTask(this._context, 'Completado desde Modo Aprendizaje', 0);

            // Optionally check badges
            const newBadges = await (await import('../services/BadgesService')).BadgesService.checkAndUnlockBadges(this._context).catch(() => []);

            // Refresh UI via event already fired by saveState
            // Close panel and open next task if there is one
            if (result.hasNext) {
                // Inform webview to close and let extension open the next learning mode
                this._panel.webview.postMessage({ type: 'taskCompletedAndMoved' });
                // Dispose panel and open next task
                this.dispose();
                await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
            } else {
                // Project complete
                this._panel.webview.postMessage({ type: 'allTasksCompleted' });
            }
        } catch (error) {
            console.error('Error completing task:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({ type: 'error', message: `Error completando tarea: ${errorMessage}` });
        }
    }

    /**
     * Carga el contenido de un paso específico con IA
     */
    private async _handleLoadStep(stepNumber: number) {
        console.log('[TaskLearningPanel] _handleLoadStep:', stepNumber);
        
        // Start the micro-lesson timer
        if (this._learningState.sessionId && this._learningState.lessons) {
            MicroLearningService.startLesson(this._context, this._learningState.sessionId, stepNumber);
        }
        
        const state = ProjectStateService.getState(this._context);
        if (!state) {
            this._panel.webview.postMessage({
                type: 'error',
                message: 'No hay proyecto activo'
            });
            return;
        }

        const currentTask = ProjectStateService.getCurrentTask(state);
        if (!currentTask) {
            this._panel.webview.postMessage({
                type: 'error',
                message: 'No hay tarea actual'
            });
            return;
        }

        // Send task information to webview
        this._panel.webview.postMessage({
            type: 'taskInfo',
            info: `${currentTask.phase.title}: ${currentTask.task}`
        });

        // Create cache key based on task and step
        const cacheKey = IntelligentCacheService.generateKey(
            'step-content',
            currentTask.phase.title,
            currentTask.task,
            stepNumber.toString()
        );

        // Try to get from intelligent cache first
        let cachedContent: any = null;
        try {
            cachedContent = await IntelligentCacheService.get(cacheKey);
            console.log('[TaskLearningPanel] cache lookup for', cacheKey, 'result:', !!cachedContent);
        } catch (cacheErr) {
            console.error('Cache error while getting step content:', cacheErr);
            cachedContent = null;
        }
        if (cachedContent) {
            this._learningState.currentStep = stepNumber;
            this._panel.webview.postMessage({
                type: 'stepLoaded',
                stepNumber,
                content: cachedContent
            });
            console.log('[TaskLearningPanel] stepLoaded from cache for step', stepNumber);
            return;
        }

        // Show loading if not in local cache
        if (!this._learningState.cachedSteps[stepNumber]) {
            this._panel.webview.postMessage({ type: 'loadingStep' });
        } else {
            // Use local cache while we check intelligent cache
            this._learningState.currentStep = stepNumber;
            this._panel.webview.postMessage({
                type: 'stepLoaded',
                stepNumber,
                content: this._learningState.cachedSteps[stepNumber]
            });
            return;
        }

        try {
            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                this._panel.webview.postMessage({
                    type: 'error',
                    message: 'Necesitas configurar tu API Key'
                });
                return;
            }

            // Generate content of the step with AI
            // Add a timeout for AI generation to avoid infinite waiting
            const aiPromise = this._generateStepContent(stepNumber, currentTask, state, apiKey);
            const timeoutMs = 60000; // 60 seconds
            
            // Inform user that content is being generated
            this._panel.webview.postMessage({
                type: 'status', 
                message: 'Generando contenido... esto puede tomar hasta 60 segundos.' 
            });

            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('La generación del contenido está tomando más tiempo del esperado. Por favor, inténtalo de nuevo.')), timeoutMs)
            );

            let stepContent: any;
            try {
                stepContent = await Promise.race([aiPromise, timeoutPromise]);
                console.log('[TaskLearningPanel] AI content generated for step', stepNumber);
            } catch (err) {
                console.error('Error generating step content:', err);
                const errorMessage = err instanceof Error ? err.message : String(err);
                this._panel.webview.postMessage({ type: 'error', message: `Error generando contenido del paso: ${errorMessage}` });
                return;
            }

            // Save to both caches
            this._learningState.cachedSteps[stepNumber] = stepContent;
            await IntelligentCacheService.set(cacheKey, stepContent);
            this._learningState.currentStep = stepNumber;

            // Save content to file
            const stepName = this._stepNames[stepNumber];
            await this._saveStepContentToFile(stepNumber, stepName, stepContent, currentTask);

            this._panel.webview.postMessage({
                type: 'stepLoaded',
                stepNumber,
                content: stepContent
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error cargando paso: ${errorMessage}`
            });
        }
    }

    /**
     * Solicita al AI que expanda el contenido del paso (generación incremental)
     */
    private async _handleContinueStep(stepNumber: number) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) throw new Error('No hay estado');

            const currentTask = ProjectStateService.getCurrentTask(state);
            if (!currentTask) throw new Error('No hay tarea actual');

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) throw new Error('No hay API Key');

            const aiService = AIServiceFactory.createService(apiKey);

            // Get existing content to provide context for expansion
            const existingContent = this._learningState.cachedSteps[stepNumber] || {};
            
            // Build a prompt asking to expand the existing step content
            const prompt = `Expande y enriquece el contenido del paso ${stepNumber + 1} para la tarea "${currentTask.task}". 
El contenido actual es:
${JSON.stringify(existingContent, null, 2)}

Proporciona más ejemplos, recursos, explicaciones y pasos accionables. Asegúrate de incluir información adicional que complemente el contenido existente, no que lo reemplace. 
Responde en JSON apropiado para el tipo de paso, manteniendo la estructura existente pero añadiendo más detalles.`;

            this._panel.webview.postMessage({ type: 'status', message: 'Generando contenido adicional...' });

            const response = await aiService.generateContent(prompt);
            const parsed = this._parseStepResponse(response, stepNumber, 'Contenido adicional');

            // Merge the new content with existing content
            const merged = this._mergeStepContent(existingContent, parsed);
            this._learningState.cachedSteps[stepNumber] = merged;

            // Save to intelligent cache
            const cacheKey = IntelligentCacheService.generateKey(
                'step-content',
                currentTask.phase.title,
                currentTask.task,
                stepNumber.toString()
            );
            await IntelligentCacheService.set(cacheKey, merged);

            // Update webview with the enriched content
            this._panel.webview.postMessage({ type: 'stepLoaded', stepNumber, content: merged });
        } catch (error) {
            console.error('Error expanding step content:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({ type: 'error', message: `Error expandiendo contenido: ${errorMessage}` });
        }
    }

    /**
     * Genera el contenido de un paso específico con IA
     */
    private async _generateStepContent(
        stepNumber: number,
        currentTask: any,
        state: any,
        apiKey: string
    ): Promise<any> {
        const aiService = AIServiceFactory.createService(apiKey);
        const progress = ProjectStateService.getProgress(state);

        const prompt = this._buildStepPrompt(
            stepNumber,
            currentTask,
            progress,
            this._stepNames
        );

        const response = await aiService.generateContent(prompt);
        return this._parseStepResponse(response, stepNumber, 'Contenido del paso');
    }

    /**
     * Parsea la respuesta del AI para un paso específico
     */
    private _parseStepResponse(response: string, stepNumber: number, responseType: string): any {
        try {
            return JSON.parse(response);
        } catch (err) {
            console.error(`Error parsing ${responseType} for step ${stepNumber}:`, err);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al parsear ${responseType}: ${err.message}`
            });
            return null;
        }
    }

    /**
     * Combina el contenido existente de un paso con el nuevo contenido generado
     */
    private _mergeStepContent(existingContent: any, newContent: any): any {
        if (typeof existingContent === 'string' && typeof newContent === 'string') {
            return existingContent + newContent;
        } else if (Array.isArray(existingContent) && Array.isArray(newContent)) {
            return existingContent.concat(newContent);
        } else if (typeof existingContent === 'object' && typeof newContent === 'object') {
            return { ...existingContent, ...newContent };
        } else {
            console.error('Incompatible types for merging step content:', existingContent, newContent);
            this._panel.webview.postMessage({
                type: 'error',
                message: 'Error al combinar contenido del paso'
            });
            return null;
        }
    }

    /**
     * Construye el prompt para la generación de contenido de un paso específico
     */
    private _buildStepPrompt(
        stepNumber: number,
        currentTask: any,
        progress: any,
        stepNames: string[]
    ): string {
        const stepName = stepNames[stepNumber];
        const progressString = progress.map((p: any) => `${p.phase.title}: ${p.task}`).join('\n');

        return `Eres un tutor experto en programación. El estudiante está trabajando en el paso ${stepNumber + 1} 
("${stepName}") de la tarea: "${currentTask.task}".
Por favor, proporciona contenido para este paso. Sé específico sobre conceptos clave, posibles dificultades
y cómo superarlas. Si es apropiado, incluye ejemplos de código o analogías que puedan ayudar a entender mejor
el concepto. Tu respuesta debe ser útil, amigable y educativa.`;
    }

    /**
     * Guarda el contenido de un paso en un archivo
     */
    private async _saveStepContentToFile(
        stepNumber: number,
        stepName: string,
        stepContent: any,
        currentTask: any
    ) {
        const taskDir = path.join(this._context.globalStoragePath, 'tasks', currentTask.phase.title, currentTask.task);
        if (!fs.existsSync(taskDir)) {
            fs.mkdirSync(taskDir, { recursive: true });
        }

        const filePath = path.join(taskDir, `${stepNumber}-${stepName}.json`);
        fs.writeFileSync(filePath, JSON.stringify(stepContent, null, 2), 'utf8');
    }

    /**
     * Maneja la solicitud de un consejo educativo
     */
    private async _handleRequestHint(message: any) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                throw new Error('No hay estado de proyecto disponible');
            }

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                throw new Error('No hay API key configurada');
            }

            const aiService = AIServiceFactory.createService(apiKey);
            const currentTask = ProjectStateService.getCurrentTask(state);
            
            if (!currentTask) {
                throw new Error('No hay tarea actual');
            }

            // Create a prompt for the AI tutor to provide a hint
            const prompt = this._buildStepPrompt(
                message.stepNumber,
                currentTask,
                ProjectStateService.getProgress(state),
                this._stepNames
            ) + '\n\nAdemás, por favor proporciona un consejo educativo específico sobre este paso.';

            const response = await aiService.generateContent(prompt);

            // Send the response to the webview chat
            this._panel.webview.postMessage({
                type: 'chatResponse',
                response: `**Consejo para ${this._stepNames[message.stepNumber]}**\n\n${response}`
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al obtener consejo: ${errorMessage}`
            });
        }
    }

    /**
     * Handle request for next level hint
     */
    private async _handleNextLevelHint(message: any) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                throw new Error('No hay estado de proyecto disponible');
            }

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                throw new Error('No hay API key configurada');
            }

            const aiService = AIServiceFactory.createService(apiKey);
            const currentTask = ProjectStateService.getCurrentTask(state);
            
            if (!currentTask) {
                throw new Error('No hay tarea actual');
            }

            // Create a prompt for the AI tutor to provide a hint
            const prompt = this._buildStepPrompt(
                message.stepNumber,
                currentTask,
                ProjectStateService.getProgress(state),
                this._stepNames
            ) + '\n\nAdemás, por favor proporciona un consejo educativo de nivel superior específico sobre este paso.';

            const response = await aiService.generateContent(prompt);

            // Send the response to the webview chat
            this._panel.webview.postMessage({
                type: 'chatResponse',
                response: `**Consejo de nivel superior para ${this._stepNames[message.stepNumber]}**\n\n${response}`
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al obtener consejo de nivel superior: ${errorMessage}`
            });
        }
    }

    /**
     * Handle request for next task
     */
    private async _handleNextTask() {
        // Close current panel and open next task
        this.dispose();
        await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
    }

    /**
     * Handle request for help from the tutor
     */
    private async _handleRequestHelp(stepNumber: number) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                throw new Error('No hay estado de proyecto disponible');
            }

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                throw new Error('No hay API key configurada');
            }

            const aiService = AIServiceFactory.createService(apiKey);
            const currentTask = ProjectStateService.getCurrentTask(state);
            
            if (!currentTask) {
                throw new Error('No hay tarea actual');
            }

            // Create a prompt for the AI tutor to provide help
            const prompt = this._buildStepPrompt(
                stepNumber,
                currentTask,
                ProjectStateService.getProgress(state),
                this._stepNames
            ) + '\n\nAdemás, por favor proporciona ayuda adicional específica sobre este paso.';

            const response = await aiService.generateContent(prompt);

            // Send the response to the webview chat
            this._panel.webview.postMessage({
                type: 'chatResponse',
                response: `**Ayuda con ${this._stepNames[stepNumber]}**\n\n${response}`
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al obtener ayuda: ${errorMessage}`
            });
        }
    }