import * as vscode from 'vscode';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { AIServiceFactory } from '../services/AIServiceFactory';
import { ProjectStateService } from '../services/ProjectStateService';
import { ConfigService } from '../services/ConfigService';
import { IntelligentCacheService } from '../services/IntelligentCacheService';
import { MicroLearningService, MicroLesson } from '../services/MicroLearningService';
import { EducationalHintsService, Hint } from '../services/EducationalHintsService';

/**
 * Estado del aprendizaje de una tarea
 */
interface TaskLearningState {
    currentStep: number;
    completedSteps: number[];
    chatHistory: { role: 'user' | 'ai'; message: string }[];
    cachedSteps: { [stepNumber: number]: any }; // Cache de pasos ya generados
    sessionId?: string; // ID for micro-learning session
    lessons?: MicroLesson[]; // Micro-lessons for this task
}

/**
 * Panel interactivo de aprendizaje para cada tarea
 * Sistema din√°mico paso a paso con IA como mentor
 */
export class TaskLearningPanel {
    public static currentPanel: TaskLearningPanel | undefined;
    private readonly _panel: vscode.WebviewPanel;
    private readonly _extensionUri: vscode.Uri;
    private readonly _context: vscode.ExtensionContext;
    private _disposables: vscode.Disposable[] = [];
    private readonly _stepNames = [
        'üéØ Entender el Objetivo',
        'üìö Conceptos Clave',
        'üí° Ejemplo Guiado',
        '‚úçÔ∏è Tu Turno - Pr√°ctica',
        '‚úÖ Validaci√≥n'
    ];
    private _learningState: TaskLearningState;

    public static async createOrShow(
        extensionUri: vscode.Uri,
        context: vscode.ExtensionContext,
        phaseIndex?: number,
        taskIndex?: number,
        roadmapId?: string
    ) {
        const column = vscode.ViewColumn.One;

        // Si ya existe un panel, mostrarlo
        if (TaskLearningPanel.currentPanel) {
            TaskLearningPanel.currentPanel._panel.reveal(column);
            await TaskLearningPanel.currentPanel._refresh();
            return;
        }

        // Crear nuevo panel
        const panel = vscode.window.createWebviewPanel(
            'knowledgeForgeLearning',
            'üìö Modo Aprendizaje - KnowledgeForge',
            column,
            {
                enableScripts: true,
                localResourceRoots: [extensionUri],
                retainContextWhenHidden: true
            }
        );

        TaskLearningPanel.currentPanel = new TaskLearningPanel(panel, extensionUri, context, phaseIndex, taskIndex, roadmapId);
    }

    public postCodeToExplain(code: string) {
        this._panel.webview.postMessage({ type: 'codeToExplain', code: code });
    }

    private constructor(
        panel: vscode.WebviewPanel,
        extensionUri: vscode.Uri,
        context: vscode.ExtensionContext,
        private readonly phaseIndex?: number,
        private readonly taskIndex?: number,
        private readonly roadmapId?: string
    ) {
        this._panel = panel;
        this._extensionUri = extensionUri;
        this._context = context;

        // Estado inicial
        this._learningState = {
            currentStep: 0,
            completedSteps: [],
            chatHistory: [],
            cachedSteps: {},
            sessionId: undefined,
            lessons: undefined
        };

        // Configurar contenido inicial
        this._update();

        // Escuchar cuando el panel es cerrado
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // Manejar mensajes desde el webview
        this._panel.webview.onDidReceiveMessage(
            async (message) => {
                try {
                    console.log('[TaskLearningPanel] onDidReceiveMessage:', message.type, message);
                    switch (message.type) {
                        case 'loadStep':
                            await this._handleLoadStep(message.stepNumber);
                            break;
                        case 'completeStep':
                            await this._handleCompleteStep(message.stepNumber);
                            break;
                        case 'completeTask':
                            await this._handleCompleteTask();
                            break;
                        case 'askAI':
                            await this._handleAskAI(message.question);
                            break;
                        case 'continueStep':
                            await this._handleContinueStep(message.stepNumber);
                            break;
                        case 'openInSandbox':
                            await this._handleOpenInSandbox(message.code || '');
                            break;
                        case 'closePanel':
                            this.dispose();
                            await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
                            break;
                        case 'requestHint':
                            await this._handleRequestHint(message);
                            break;
                        case 'requestHelp':
                            await this._handleRequestHelp(message.stepNumber);
                            break;
                        case 'nextLevelHint':
                            await this._handleNextLevelHint(message);
                            break;
                        case 'navigateToNextTask':
                            try {
                                // Close current panel first
                                this.dispose();

                                // Advance the project pointer to next task
                                await vscode.commands.executeCommand('knowledgeforge.nextTask');

                                // Re-open the learning mode for the new current task
                                await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
                            } catch (err) {
                                console.error('Error navigating to next task:', err);
                            }
                            break;
                        case 'webviewError':
                            // Forward webview rendering/parsing errors to Extension Host logs for debugging
                            try {
                                console.error('[TaskLearningPanel] Webview reported error on step', message.stepNumber + ':', message.error);
                                vscode.window.showErrorMessage('KnowledgeForge webview error: ' + (message.error || 'unknown error'));
                            } catch (e) {
                                console.error('Failed to handle webviewError message:', e);
                            }
                            break;
                        default:
                            console.warn('[TaskLearningPanel] Unknown message type:', message.type);
                    }
                } catch (err) {
                    console.error('[TaskLearningPanel] Error handling message:', message, err);
                }
            },
            null,
            this._disposables
        );

    }

    private async _refresh() {
        // Initialize micro-learning session if not already done
        if (!this._learningState.sessionId && this.phaseIndex !== undefined && this.taskIndex !== undefined) {
            const taskId = `${this.roadmapId || 'default'}-${this.phaseIndex}-${this.taskIndex}`;
            const session = MicroLearningService.getSession(this._context, taskId) || 
                           MicroLearningService.startSession(this._context, taskId, this._stepNames);
            
            this._learningState.sessionId = session.taskId;
            this._learningState.lessons = session.lessons;
        }
        
        this._update();
    }

    private async _handleOpenInSandbox(code: string) {
        try {
            // Create a temp file to avoid using the untitled: scheme which causes FS provider errors
            const tmpDir = path.join(os.tmpdir(), 'knowledgeforge_sandbox');
            if (!fs.existsSync(tmpDir)) {
                fs.mkdirSync(tmpDir, { recursive: true });
            }

            const filePath = path.join(tmpDir, `sandbox_${Date.now()}.ts`);
            fs.writeFileSync(filePath, code || '', 'utf8');

            const document = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            await vscode.window.showTextDocument(document, vscode.ViewColumn.Beside);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({ type: 'error', message: `Error abriendo sandbox: ${errorMessage}` });
        }
    }

    private async _handleCompleteTask() {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                this._panel.webview.postMessage({ type: 'error', message: 'No hay proyecto activo' });
                return;
            }

            // Complete current task and get whether there's a next
            const result = await ProjectStateService.completeCurrentTask(this._context, 'Completado desde Modo Aprendizaje', 0);

            // Optionally check badges
            const newBadges = await (await import('../services/BadgesService')).BadgesService.checkAndUnlockBadges(this._context).catch(() => []);

            // Refresh UI via event already fired by saveState
            // Close panel and open next task if there is one
            if (result.hasNext) {
                // Inform webview to close and let extension open the next learning mode
                this._panel.webview.postMessage({ type: 'taskCompletedAndMoved' });
                // Dispose panel and open next task
                this.dispose();
                await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
            } else {
                // Project complete
                this._panel.webview.postMessage({ type: 'allTasksCompleted' });
            }
        } catch (error) {
            console.error('Error completing task:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({ type: 'error', message: `Error completando tarea: ${errorMessage}` });
        }
    }

    /**
     * Carga el contenido de un paso espec√≠fico con IA
     */
    private async _handleLoadStep(stepNumber: number) {
        console.log('[TaskLearningPanel] _handleLoadStep:', stepNumber);
        
        // Start the micro-lesson timer
        if (this._learningState.sessionId && this._learningState.lessons) {
            MicroLearningService.startLesson(this._context, this._learningState.sessionId, stepNumber);
        }
        
        const state = ProjectStateService.getState(this._context);
        if (!state) {
            this._panel.webview.postMessage({
                type: 'error',
                message: 'No hay proyecto activo'
            });
            return;
        }

        const currentTask = ProjectStateService.getCurrentTask(state);
        if (!currentTask) {
            this._panel.webview.postMessage({
                type: 'error',
                message: 'No hay tarea actual'
            });
            return;
        }

        // Send task information to webview
        this._panel.webview.postMessage({
            type: 'taskInfo',
            info: `${currentTask.phase.title}: ${currentTask.task}`
        });

        // Create cache key based on task and step
        const cacheKey = IntelligentCacheService.generateKey(
            'step-content',
            currentTask.phase.title,
            currentTask.task,
            stepNumber.toString()
        );

        // Try to get from intelligent cache first
        let cachedContent: any = null;
        try {
            cachedContent = await IntelligentCacheService.get(cacheKey);
            console.log('[TaskLearningPanel] cache lookup for', cacheKey, 'result:', !!cachedContent);
        } catch (cacheErr) {
            console.error('Cache error while getting step content:', cacheErr);
            cachedContent = null;
        }
        if (cachedContent) {
            this._learningState.currentStep = stepNumber;
            this._panel.webview.postMessage({
                type: 'stepLoaded',
                stepNumber,
                content: cachedContent
            });
            console.log('[TaskLearningPanel] stepLoaded from cache for step', stepNumber);
            return;
        }

        // Show loading if not in local cache
        if (!this._learningState.cachedSteps[stepNumber]) {
            this._panel.webview.postMessage({ type: 'loadingStep' });
        } else {
            // Use local cache while we check intelligent cache
            this._learningState.currentStep = stepNumber;
            this._panel.webview.postMessage({
                type: 'stepLoaded',
                stepNumber,
                content: this._learningState.cachedSteps[stepNumber]
            });
            return;
        }

        try {
            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                this._panel.webview.postMessage({
                    type: 'error',
                    message: 'Necesitas configurar tu API Key'
                });
                return;
            }

            // Generate content of the step with AI
            // Add a timeout for AI generation to avoid infinite waiting
            const aiPromise = this._generateStepContent(stepNumber, currentTask, state, apiKey);
            const timeoutMs = 60000; // 60 seconds
            
            // Inform user that content is being generated
            this._panel.webview.postMessage({
                type: 'status', 
                message: 'Generando contenido... esto puede tomar hasta 60 segundos.' 
            });

            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('La generaci√≥n del contenido est√° tomando m√°s tiempo del esperado. Por favor, int√©ntalo de nuevo.')), timeoutMs)
            );

            let stepContent: any;
            try {
                stepContent = await Promise.race([aiPromise, timeoutPromise]);
                console.log('[TaskLearningPanel] AI content generated for step', stepNumber);
            } catch (err) {
                console.error('Error generating step content:', err);
                const errorMessage = err instanceof Error ? err.message : String(err);
                this._panel.webview.postMessage({ type: 'error', message: `Error generando contenido del paso: ${errorMessage}` });
                return;
            }

            // Save to both caches
            this._learningState.cachedSteps[stepNumber] = stepContent;
            await IntelligentCacheService.set(cacheKey, stepContent);
            this._learningState.currentStep = stepNumber;

            // Save content to file
            const stepName = this._stepNames[stepNumber];
            await this._saveStepContentToFile(stepNumber, stepName, stepContent, currentTask);

            this._panel.webview.postMessage({
                type: 'stepLoaded',
                stepNumber,
                content: stepContent
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error cargando paso: ${errorMessage}`
            });
        }
    }

    /**
     * Solicita al AI que expanda el contenido del paso (generaci√≥n incremental)
     */
    private async _handleContinueStep(stepNumber: number) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) throw new Error('No hay estado');

            const currentTask = ProjectStateService.getCurrentTask(state);
            if (!currentTask) throw new Error('No hay tarea actual');

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) throw new Error('No hay API Key');

            const aiService = AIServiceFactory.createService(apiKey);

            // Get existing content to provide context for expansion
            const existingContent = this._learningState.cachedSteps[stepNumber] || {};
            
            // Build a prompt asking to expand the existing step content
            const prompt = `Expande y enriquece el contenido del paso ${stepNumber + 1} para la tarea "${currentTask.task}". 
El contenido actual es:
${JSON.stringify(existingContent, null, 2)}

Proporciona m√°s ejemplos, recursos, explicaciones y pasos accionables. Aseg√∫rate de incluir informaci√≥n adicional que complemente el contenido existente, no que lo reemplace. 
Responde en JSON apropiado para el tipo de paso, manteniendo la estructura existente pero a√±adiendo m√°s detalles.`;

            this._panel.webview.postMessage({ type: 'status', message: 'Generando contenido adicional...' });

            const response = await aiService.generateContent(prompt);
            const parsed = this._parseStepResponse(response, stepNumber, 'Contenido adicional');

            // Merge the new content with existing content
            const merged = this._mergeStepContent(existingContent, parsed);
            this._learningState.cachedSteps[stepNumber] = merged;

            // Save to intelligent cache
            const cacheKey = IntelligentCacheService.generateKey(
                'step-content',
                currentTask.phase.title,
                currentTask.task,
                stepNumber.toString()
            );
            await IntelligentCacheService.set(cacheKey, merged);

            // Update webview with the enriched content
            this._panel.webview.postMessage({ type: 'stepLoaded', stepNumber, content: merged });
        } catch (error) {
            console.error('Error expanding step content:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({ type: 'error', message: `Error expandiendo contenido: ${errorMessage}` });
        }
    }

    /**
     * Genera el contenido de un paso espec√≠fico con IA
     */
    private async _generateStepContent(
        stepNumber: number,
        currentTask: any,
        state: any,
        apiKey: string
    ): Promise<any> {
        const aiService = AIServiceFactory.createService(apiKey);
        const progress = ProjectStateService.getProgress(state);

        const prompt = this._buildStepPrompt(
            stepNumber,
            currentTask,
            progress,
            this._stepNames
        );

        const response = await aiService.generateContent(prompt);
        return this._parseStepResponse(response, stepNumber, 'Contenido del paso');
    }

    /**
     * Parsea la respuesta del AI para un paso espec√≠fico
     */
    private _parseStepResponse(response: string, stepNumber: number, responseType: string): any {
        try {
            return JSON.parse(response);
        } catch (err) {
            console.error(`Error parsing ${responseType} for step ${stepNumber}:`, err);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al parsear ${responseType}: ${err.message}`
            });
            return null;
        }
    }

    /**
     * Combina el contenido existente de un paso con el nuevo contenido generado
     */
    private _mergeStepContent(existingContent: any, newContent: any): any {
        if (typeof existingContent === 'string' && typeof newContent === 'string') {
            return existingContent + newContent;
        } else if (Array.isArray(existingContent) && Array.isArray(newContent)) {
            return existingContent.concat(newContent);
        } else if (typeof existingContent === 'object' && typeof newContent === 'object') {
            return { ...existingContent, ...newContent };
        } else {
            console.error('Incompatible types for merging step content:', existingContent, newContent);
            this._panel.webview.postMessage({
                type: 'error',
                message: 'Error al combinar contenido del paso'
            });
            return null;
        }
    }

    /**
     * Construye el prompt para la generaci√≥n de contenido de un paso espec√≠fico
     */
    private _buildStepPrompt(
        stepNumber: number,
        currentTask: any,
        progress: any,
        stepNames: string[]
    ): string {
        const stepName = stepNames[stepNumber];
        const progressString = progress.map((p: any) => `${p.phase.title}: ${p.task}`).join('\n');

        return `Eres un tutor experto en programaci√≥n. El estudiante est√° trabajando en el paso ${stepNumber + 1} 
("${stepName}") de la tarea: "${currentTask.task}".
Por favor, proporciona contenido para este paso. S√© espec√≠fico sobre conceptos clave, posibles dificultades
y c√≥mo superarlas. Si es apropiado, incluye ejemplos de c√≥digo o analog√≠as que puedan ayudar a entender mejor
el concepto. Tu respuesta debe ser √∫til, amigable y educativa.`;
    }

    /**
     * Guarda el contenido de un paso en un archivo
     */
    private async _saveStepContentToFile(
        stepNumber: number,
        stepName: string,
        stepContent: any,
        currentTask: any
    ) {
        const taskDir = path.join(this._context.globalStoragePath, 'tasks', currentTask.phase.title, currentTask.task);
        if (!fs.existsSync(taskDir)) {
            fs.mkdirSync(taskDir, { recursive: true });
        }

        const filePath = path.join(taskDir, `${stepNumber}-${stepName}.json`);
        fs.writeFileSync(filePath, JSON.stringify(stepContent, null, 2), 'utf8');
    }

    /**
     * Maneja la solicitud de un consejo educativo
     */
    private async _handleRequestHint(message: any) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                throw new Error('No hay estado de proyecto disponible');
            }

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                throw new Error('No hay API key configurada');
            }

            const aiService = AIServiceFactory.createService(apiKey);
            const currentTask = ProjectStateService.getCurrentTask(state);
            
            if (!currentTask) {
                throw new Error('No hay tarea actual');
            }

            // Create a prompt for the AI tutor to provide a hint
            const prompt = this._buildStepPrompt(
                message.stepNumber,
                currentTask,
                ProjectStateService.getProgress(state),
                this._stepNames
            ) + '\n\nAdem√°s, por favor proporciona un consejo educativo espec√≠fico sobre este paso.';

            const response = await aiService.generateContent(prompt);

            // Send the response to the webview chat
            this._panel.webview.postMessage({
                type: 'chatResponse',
                response: `**Consejo para ${this._stepNames[message.stepNumber]}**\n\n${response}`
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al obtener consejo: ${errorMessage}`
            });
        }
    }

    /**
     * Handle request for next level hint
     */
    private async _handleNextLevelHint(message: any) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                throw new Error('No hay estado de proyecto disponible');
            }

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                throw new Error('No hay API key configurada');
            }

            const aiService = AIServiceFactory.createService(apiKey);
            const currentTask = ProjectStateService.getCurrentTask(state);
            
            if (!currentTask) {
                throw new Error('No hay tarea actual');
            }

            // Create a prompt for the AI tutor to provide a hint
            const prompt = this._buildStepPrompt(
                message.stepNumber,
                currentTask,
                ProjectStateService.getProgress(state),
                this._stepNames
            ) + '\n\nAdem√°s, por favor proporciona un consejo educativo de nivel superior espec√≠fico sobre este paso.';

            const response = await aiService.generateContent(prompt);

            // Send the response to the webview chat
            this._panel.webview.postMessage({
                type: 'chatResponse',
                response: `**Consejo de nivel superior para ${this._stepNames[message.stepNumber]}**\n\n${response}`
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al obtener consejo de nivel superior: ${errorMessage}`
            });
        }
    }

    /**
     * Handle request for next task
     */
    private async _handleNextTask() {
        // Close current panel and open next task
        this.dispose();
        await vscode.commands.executeCommand('knowledgeforge.openLearningMode');
    }

    /**
     * Handle request for help from the tutor
     */
    private async _handleRequestHelp(stepNumber: number) {
        try {
            const state = ProjectStateService.getState(this._context);
            if (!state) {
                throw new Error('No hay estado de proyecto disponible');
            }

            const apiKey = await ConfigService.getApiKey(this._context);
            if (!apiKey) {
                throw new Error('No hay API key configurada');
            }

            const aiService = AIServiceFactory.createService(apiKey);
            const currentTask = ProjectStateService.getCurrentTask(state);
            
            if (!currentTask) {
                throw new Error('No hay tarea actual');
            }

            // Create a prompt for the AI tutor to provide help
            const prompt = this._buildStepPrompt(
                stepNumber,
                currentTask,
                ProjectStateService.getProgress(state),
                this._stepNames
            ) + '\n\nAdem√°s, por favor proporciona ayuda adicional espec√≠fica sobre este paso.';

            const response = await aiService.generateContent(prompt);

            // Send the response to the webview chat
            this._panel.webview.postMessage({
                type: 'chatResponse',
                response: `**Ayuda con ${this._stepNames[stepNumber]}**\n\n${response}`
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this._panel.webview.postMessage({
                type: 'error',
                message: `Error al obtener ayuda: ${errorMessage}`
            });
        }
    }